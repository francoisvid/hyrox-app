import Foundation
import CoreData
import Combine
import WatchConnectivity

@MainActor
class WorkoutViewModel: ObservableObject {
    // MARK: - Inputs
    @Published var selectedExercise: Exercise?
    @Published var isEditingExercise: Bool = false
    @Published var debugMessage: String = ""
    @Published var showDebug: Bool = false

    // MARK: - Outputs
    @Published private(set) var currentExercises: [Exercise] = []
    @Published private(set) var workoutProgress: Double = 0
    @Published private(set) var elapsedTime: TimeInterval = 0
    @Published private(set) var isActive: Bool = false
    @Published private(set) var templates: [WorkoutTemplate] = []

    // MARK: - Dependencies
    let workoutManager: WorkoutManager
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Init
    init(workoutManager: WorkoutManager) {
        self.workoutManager = workoutManager

        // Observer l'√©tat courant, l'activation et le temps √©coul√©
        Publishers.CombineLatest3(
            workoutManager.$currentWorkout,
            workoutManager.$isWorkoutActive,
            workoutManager.$elapsedTime
        )
        .receive(on: RunLoop.main)
        .sink { [weak self] workout, active, elapsed in
            guard let self = self else { return }
            self.isActive = active
            self.elapsedTime = elapsed

            if active, let w = workout {
                self.currentExercises = w.orderedExercises
                self.updateProgress(for: w)
            } else {
                self.currentExercises = []
                self.workoutProgress = 0
            }
        }
        .store(in: &cancellables)
        
        // Observer les notifications de nouveaux templates
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleNewTemplate),
            name: NSNotification.Name("WorkoutTemplateReceived"),
            object: nil
        )
        
        // Charger les templates et les workouts
        loadTemplates()
        reloadWorkouts()
    }

    @objc private func handleNewTemplate(_ notification: Notification) {
        print("üîµ WorkoutViewModel - Nouveau template re√ßu")
        
        // V√©rifier si on doit ignorer la synchronisation
        if let skipSync = notification.userInfo?["skipSync"] as? Bool, skipSync {
            print("‚è≠Ô∏è Synchronisation ignor√©e pour √©viter la boucle")
            loadTemplates()
            return
        }
        
        loadTemplates()
    }

    // MARK: - Actions
    func startWorkout(from template: WorkoutTemplate? = nil) {
        print("üîµ WorkoutViewModel - startWorkout appel√©")
        
        // R√©initialiser l'√©tat
        currentExercises = []
        workoutProgress = 0
        elapsedTime = 0
        isActive = false
        
        if let template = template {
            print("üîµ WorkoutViewModel - D√©marrage avec template: \(template.name ?? "Sans nom")")
            workoutManager.startWorkoutFromTemplate(template)
        } else {
            print("üîµ WorkoutViewModel - D√©marrage sans template")
            workoutManager.startNewWorkout()
        }
        
        // Attendre que le workout soit initialis√©
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
            guard let self = self else { return }
            print("üîµ WorkoutViewModel - V√©rification apr√®s d√©lai")
            print("üîµ WorkoutViewModel - Workout d√©marr√©, currentWorkout: \(self.workoutManager.currentWorkout?.id?.uuidString ?? "nil")")
            print("üîµ WorkoutViewModel - isActive: \(self.workoutManager.isWorkoutActive)")
            print("üîµ WorkoutViewModel - Nombre d'exercices: \(self.workoutManager.currentWorkout?.exercises?.count ?? 0)")
            
            // Forcer la mise √† jour de l'UI
            self.objectWillChange.send()
            
            // Sauvegarder et synchroniser
            self.saveAndSync(self.workoutManager.currentWorkout)
        }
    }
    
    func createTemplate(name: String, description: String, exercises: [String]) {
        print("üîµ WorkoutViewModel - createTemplate appel√©")
        let context = DataController.shared.container.viewContext
        let template = WorkoutTemplate(context: context)
        template.id = UUID()
        template.name = name
        template.workoutDescription = description
        template.createdAt = Date()
        template.isPublic = false
        
        // Calculer la dur√©e estim√©e
        var totalDuration: TimeInterval = 0
        for exerciseName in exercises {
            if let def = ExerciseDefinitions.all[exerciseName] {
                totalDuration += def.targetTime ?? 0
            }
        }
        template.estimatedDuration = totalDuration
        
        // Ajouter les exercices
        for (index, exerciseName) in exercises.enumerated() {
            let exerciseTemplate = ExerciseTemplate(context: context)
            exerciseTemplate.id = UUID()
            exerciseTemplate.name = exerciseName
            exerciseTemplate.order = Int16(index)
            exerciseTemplate.workoutTemplate = template
            
            if let def = ExerciseDefinitions.all[exerciseName] {
                exerciseTemplate.defaultDuration = def.targetTime ?? 0
                exerciseTemplate.defaultDistance = def.standardDistance ?? 0
                exerciseTemplate.defaultRepetitions = Int16(def.standardRepetitions ?? 0)
                exerciseTemplate.exerciseDescription = def.description
            }
        }
        
        // Sauvegarder et synchroniser
        DataController.shared.saveContext()
        DataSyncManager.shared.sendWorkoutTemplate(template)
        loadTemplates()
        print("üîµ WorkoutViewModel - Template cr√©√©: \(template.id?.uuidString ?? "nil")")
    }

    func endWorkout() {
        print("üîµ WorkoutViewModel - endWorkout appel√©")
        workoutManager.endWorkout()
        saveAndSync()
    }

    func forceRefresh() {
        print("üîµ WorkoutViewModel - forceRefresh appel√©")
        objectWillChange.send()
        loadTemplates()
        reloadWorkouts()
    }
    
    func reloadWorkouts() {
        print("üîµ WorkoutViewModel - reloadWorkouts appel√©")
        workoutManager.loadWorkouts()
        objectWillChange.send() // Force UI update
        print("üîÑ WorkoutViewModel recharg√©: \(workouts.count) workouts")
    }
    
    func loadTemplates() {
        print("üîµ WorkoutViewModel - loadTemplates appel√©")
        let context = DataController.shared.container.viewContext
        let request: NSFetchRequest<WorkoutTemplate> = WorkoutTemplate.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \WorkoutTemplate.createdAt, ascending: false)]
        do {
            templates = try context.fetch(request)
            print("üîµ WorkoutViewModel - Templates charg√©s: \(templates.count)")
        } catch {
            print("Erreur chargement templates: \(error)")
        }
    }
    
    func saveAndSync(_ workout: Workout? = nil) {
        print("üîµ WorkoutViewModel - saveAndSync appel√©")
        // Sauvegarder dans Core Data
        DataController.shared.saveContext()
        
        // Synchroniser avec l'autre appareil
        if let workout = workout {
            // Si un workout sp√©cifique est fourni
            DataSyncManager.shared.sendWorkout(workout)
            print("üîµ WorkoutViewModel - Workout synchronis√©: \(workout.id?.uuidString ?? "nil")")
        } else if let currentWorkout = workoutManager.currentWorkout {
            // Utiliser le workout actuel du manager
            DataSyncManager.shared.sendWorkout(currentWorkout)
            print("üîµ WorkoutViewModel - Workout actuel synchronis√©: \(currentWorkout.id?.uuidString ?? "nil")")
        }
    }
    
    func completeExercise(exercise: Exercise, duration: TimeInterval, distance: Double, repetitions: Int) {
        exercise.duration = duration
        exercise.distance = distance
        exercise.repetitions = Int16(repetitions)
        
        // Sauvegarder et synchroniser le workout parent
        if let workout = exercise.workout {
            saveAndSync(workout)
        } else {
            DataController.shared.saveContext()
        }
    }

    // MARK: - Helpers
    func isExerciseCompleted(_ exercise: Exercise) -> Bool {
        return exercise.duration > 0
    }

    private func updateProgress(for workout: Workout) {
        let exercises = workout.orderedExercises
        guard !exercises.isEmpty else {
            workoutProgress = 0
            return
        }
        let done = exercises.filter { $0.duration > 0 }.count
        workoutProgress = Double(done) / Double(exercises.count) * 100
    }

    func formatTime(_ seconds: TimeInterval) -> String {
        TimeFormatter.formatTime(seconds)
    }
    
    func select(_ exercise: Exercise) {
        selectedExercise = exercise
        isEditingExercise = true
    }
    
    func isNext(_ exercise: Exercise) -> Bool {
        guard let workout = workoutManager.currentWorkout else { return false }
        return workout.orderedExercises.first(where: { $0.duration <= 0 })?.id == exercise.id
    }

    // MARK: - Preview Helpers
    #if DEBUG
    func setPreviewTemplates(_ templates: [WorkoutTemplate]) {
        self.templates = templates
    }
    #endif

    // MARK: - Expos√©s pour la Watch
    var workouts: [Workout] {
        workoutManager.workouts
    }

    var personalBests: [String: Exercise] {
        workoutManager.personalBests
    }

    func clearAllData() {
        debugMessage = "Suppression de toutes les donn√©es..."
        showDebug = true
        
        // Appeler la m√©thode de DataController
        DataController.shared.clearAllData()
        
        // Envoyer un message de synchronisation pour informer l'iPhone
        let message: [String: Any] = [
            "action": "clearAllData",
            "timestamp": Date().timeIntervalSince1970
        ]
        
        if WCSession.default.activationState == .activated {
            WCSession.default.sendMessage(message, replyHandler: nil) { error in
                print("‚ùå Erreur lors de l'envoi du message de suppression:", error)
            }
        }
        
        // Forcer la mise √† jour du ViewModel et de la vue
        DispatchQueue.main.async {
            self.reloadWorkouts()
            self.objectWillChange.send() // Force la mise √† jour de la vue
            self.debugMessage = "‚úÖ Toutes les donn√©es ont √©t√© effac√©es"
            
            // Masquer le message apr√®s quelques secondes
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                self.showDebug = false
            }
        }
    }

    // Nouvelle fonction pour supprimer tous les templates
    func deleteAllTemplates() {
        print("üîµ WorkoutViewModel - Suppression de tous les templates")
        let context = DataController.shared.container.viewContext
        
        // 1. Supprimer de Core Data
        let fetchRequest: NSFetchRequest<WorkoutTemplate> = WorkoutTemplate.fetchRequest()
        do {
            let templates = try context.fetch(fetchRequest)
            for template in templates {
                context.delete(template)
            }
            try context.save()
            print("‚úÖ Templates supprim√©s de Core Data")
            
            // 2. Supprimer de Firebase
            #if os(iOS)
            Task {
                do {
                    try await DataSyncManager.shared.deleteAllTemplatesFromFirebase()
                    print("‚úÖ Templates supprim√©s de Firebase")
                    
                    // 3. Envoyer un message √† la Watch pour la synchronisation
                    let message: [String: Any] = [
                        "action": "templatesDeleted",
                        "timestamp": Date().timeIntervalSince1970
                    ]
                    
                    if WCSession.default.activationState == .activated {
                        WCSession.default.sendMessage(message, replyHandler: nil) { error in
                            print("‚ùå Erreur lors de l'envoi du message de suppression des templates:", error)
                        }
                    }
                    
                    // 4. Recharger les templates apr√®s la suppression
                    await MainActor.run {
                        self.loadTemplates()
                    }
                } catch {
                    print("‚ùå Erreur lors de la suppression des templates de Firebase:", error)
                }
            }
            #endif
            
        } catch {
            print("‚ùå Erreur lors de la suppression des templates:", error)
        }
    }
}
